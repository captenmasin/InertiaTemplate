"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const messages_1 = require("../constants/messages");
const eslint_1 = require("../services/eslint");
const imports_1 = require("../services/imports");
const opts = {
    DISABLE_LINE_SORTS: "no-line-length-sort",
    SORT_BY_SPECIFIER: "sort-by-specifiers-length",
};
exports.default = {
    meta: {
        fixable: "code",
    },
    schema: [
        {
            enum: [opts.DISABLE_LINE_SORTS, opts.SORT_BY_SPECIFIER],
        },
    ],
    create: (context) => {
        const sourceCode = context.getSourceCode();
        const calculateSortIndex = imports_1.createCalculateSortIndex(sourceCode, {
            sortBySpecifier: context.options.includes(opts.SORT_BY_SPECIFIER),
            disableLineSorts: context.options.includes(opts.DISABLE_LINE_SORTS),
        });
        return {
            Program: (program) => {
                const imports = imports_1.getImportsWithNodesBetween(program);
                if (!imports.length) {
                    return;
                }
                const firstNotSorted = imports_1.getFirstNotSorted(imports, calculateSortIndex);
                if (firstNotSorted) {
                    const autoFix = (fixer) => {
                        const importsStart = imports[0].range[0];
                        const importsEnd = eslint_1.getNodeEndPosition(sourceCode, imports[imports.length - 1]);
                        const sortedImports = imports.sort((a, b) => calculateSortIndex(a) - calculateSortIndex(b));
                        let metNonImportNode = false;
                        // do not add additional \n to the end of imports
                        const addSeparatorBetweenNodes = (source, index) => {
                            const node = sortedImports[index];
                            if (!metNonImportNode && !imports_1.isImportDeclaration(node)) {
                                metNonImportNode = true;
                                source = "\n" + source;
                            }
                            return index < sortedImports.length - 1 ? source + "\n" : source;
                        };
                        const sortedImportsText = eslint_1.nodesArrayToText(sourceCode)(sortedImports, addSeparatorBetweenNodes);
                        return fixer.replaceTextRange([importsStart, importsEnd], sortedImportsText);
                    };
                    context.report({
                        fix: autoFix,
                        loc: firstNotSorted.loc,
                        message: messages_1.messages.NOT_SORTED,
                    });
                }
            },
        };
    },
};
//# sourceMappingURL=sorted.js.map